//! The DHCP client state module.

use std::{fmt, net::Ipv4Addr, task::{Context, Poll}, time::{Duration, Instant}};

use rand;
use pin_project::pin_project;
use std::pin::Pin;
use tokio::time::{sleep as tokio_sleep, Sleep};
use futures::{Stream, Future};

use dhcp_protocol::Message;

use crate::backoff::Backoff;
use crate::forthon::Forthon;

/// Initial timeout in seconds for the BEB timers.
const BACKOFF_TIMEOUT_INITIAL: u64 = 4;
/// Maximum timeout in seconds for the BEB timers.
const BACKOFF_TIMEOUT_MAXIMUM: u64 = 64;
/// Minimal stimeout in seconds for the BEFâ„¢ timers.
const FORTHON_TIMEOUT_MINIMAL: u64 = 60;
/// Is used if a server does not provide the `renewal_time` option.
const RENEWAL_TIME_FACTOR: f64 = 0.5;
/// Is used if a server does not provide the `rebinding_time` option.
const REBINDING_TIME_FACTOR: f64 = 0.875;

/// RFC 2131 DHCP states.
///
/// The ones end with `Sent` are not described in RFC 2131 and
/// are just substates to tell if the request has been sent or not.
#[derive(Clone, Copy)]
pub enum DhcpState {
    Init,
    Selecting,
    SelectingSent,
    Requesting,
    RequestingSent,
    InitReboot,
    Rebooting,
    RebootingSent,
    Bound,
    Renewing,
    RenewingSent,
    Rebinding,
    RebindingSent,
}

impl fmt::Display for DhcpState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use self::DhcpState::*;
        match self {
            Init => write!(f, "INIT"),
            Selecting => write!(f, "SELECTING"),
            SelectingSent => write!(f, "SELECTING_SENT"),
            Requesting => write!(f, "REQUESTING"),
            RequestingSent => write!(f, "REQUESTING_SENT"),
            InitReboot => write!(f, "INITREBOOT"),
            Rebooting => write!(f, "REBOOTING"),
            RebootingSent => write!(f, "REBOOTING_SENT"),
            Bound => write!(f, "BOUND"),
            Renewing => write!(f, "RENEWING"),
            RenewingSent => write!(f, "RENEWING_SENT"),
            Rebinding => write!(f, "REBINDING"),
            RebindingSent => write!(f, "REBINDING_SENT"),
        }
    }
}

/// Mutable `Client` data.
#[pin_project]
pub struct State {
    /// Current DHCP client state (RFC 2131).
    dhcp_state: DhcpState,
    /// If the client requires broadcast response (e.g. if it is not configured yet).
    is_broadcast: bool,
    /// Generated by the client for each session.
    transaction_id: u32,
    /// Recorded by the client from the selected `DHCPOFFER`.
    offered_address: Ipv4Addr,
    /// Recorded by the client from the selected `DHCPOFFER`.
    offered_time: u32,
    /// The address of the server selected from a `DHCPOFFER`.
    dhcp_server_id: Option<Ipv4Addr>,
    /// Recorded by the client from the `DhcpAck`.
    assigned_address: Ipv4Addr,

    /// Recorded by the client right before sending the `DhcpRequest`.
    requested_at: Instant,
    /// Seconds from `BOUND` till `RENEWING` state.
    renewal_after: u64,
    /// Seconds from `RENEWING` till `REBINDING` state.
    rebinding_after: u64,
    /// Seconds from `REBINDING` till lease expiration.
    expiration_after: u64,

    /// DHCPOFFER receive deadline.
    #[pin]
    pub timer_offer: Option<Backoff>,
    /// DHCPACK or DHCPNAK receive deadline.
    #[pin]
    pub timer_ack: Option<Backoff>,
    /// Renewal timer (so called T1 in RFC 2131).
    #[pin]
    pub timer_renewal: Option<Sleep>,
    /// Rebinding timer (so called T2 in RFC 2131).
    #[pin]
    pub timer_rebinding: Option<Forthon>,
    /// Lease expiration timer.
    #[pin]
    pub timer_expiration: Option<Forthon>,
}



impl State {
    /// Constructs a default state.
    pub fn new(
        dhcp_state: DhcpState,
        server_address: Option<Ipv4Addr>,
        is_broadcast: bool,
    ) -> Self {
        State {
            dhcp_state,
            is_broadcast,
            transaction_id: rand::random::<u32>(),
            offered_address: Ipv4Addr::new(0, 0, 0, 0),
            offered_time: 0u32,
            dhcp_server_id: server_address,
            assigned_address: Ipv4Addr::new(0, 0, 0, 0),

            requested_at: Instant::now(),
            renewal_after: 0u64,
            rebinding_after: 0u64,
            expiration_after: 0u64,

            timer_offer: None,
            timer_ack: None,
            timer_renewal: None,
            timer_rebinding: None,
            timer_expiration: None,
        }
    }

    fn set_state(self: &mut Pin<&mut Self>, state: DhcpState) {
        *self.as_mut().project().dhcp_state = state;
    }

    /// Moves the client from one state to another.
    ///
    /// # Panics
    /// On an unexpected state transcension.
    pub fn transcend(mut self: Pin<&mut Self>, from: DhcpState, to: DhcpState, response: Option<&Message>) {
        use self::DhcpState::*;
        trace!("Transcending from {} to {}", from, to);

        match from {
            // No timers are set
            Init => match to {
                next @ Selecting => {
                    self.set_dhcp_server_id(None);
                    self.set_timer_offer();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_offer is set
            Selecting => match to {
                next @ SelectingSent => {
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_offer is set
            SelectingSent => match to {
                next @ Selecting => {
                    *self.as_mut().project().dhcp_state = next;
                }
                next @ Requesting => {
                    let offer = expect!(response);
                    self.set_dhcp_server_id(Some(expect!(offer.options.dhcp_server_id)));
                    self.set_offered_address(offer.your_ip_address);
                    self.set_offered_time(expect!(offer.options.address_time));
                    self.clear_timer_offer();
                    self.set_timer_ack();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_ack is set
            Requesting => match to {
                next @ RequestingSent => {
                    self.record_request_time();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_ack is set
            RequestingSent => match to {
                next @ Init => {
                    self.clear_timer_ack();
                    self.set_state(next);
                }
                next @ Requesting => {
                    self.set_state(next);
                }
                next @ Bound => {
                    let ack = expect!(response);
                    self.set_assigned_address(ack.your_ip_address);
                    self.set_times(
                        ack.options.renewal_time,
                        ack.options.rebinding_time,
                        expect!(ack.options.address_time),
                    );
                    self.clear_timer_ack();
                    self.set_timer_renewal();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },

            // No timers are set
            InitReboot => match to {
                next @ Rebooting => {
                    self.set_timer_ack();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_ack is set
            Rebooting => match to {
                next @ RebootingSent => {
                    self.record_request_time();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_ack is set
            RebootingSent => match to {
                next @ Init => {
                    self.clear_timer_ack();
                    self.set_state(next);
                }
                next @ Rebooting => {
                    self.set_state(next);
                }
                next @ Bound => {
                    let ack = expect!(response);
                    self.set_assigned_address(ack.your_ip_address);
                    self.set_dhcp_server_id(Some(expect!(ack.options.dhcp_server_id)));
                    self.set_times(
                        ack.options.renewal_time,
                        ack.options.rebinding_time,
                        expect!(ack.options.address_time),
                    );
                    self.clear_timer_ack();
                    // We are going to Bound state, we must set timer_renewal
                    self.set_timer_renewal();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_renewal is set
            // timer_renewal is a future, all incoming states should set it
            Bound => match to {
                next @ Renewing => {
                    self.clear_timer_renewal();
                    self.set_timer_rebinding();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_rebinding is set
            Renewing => match to {
                next @ RenewingSent => {
                    self.record_request_time();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_rebinding is set
            RenewingSent => match to {
                next @ Bound => {
                    let ack = expect!(response);
                    self.set_assigned_address(ack.your_ip_address);
                    self.set_dhcp_server_id(Some(expect!(ack.options.dhcp_server_id)));
                    self.set_times(
                        ack.options.renewal_time,
                        ack.options.rebinding_time,
                        expect!(ack.options.address_time),
                    );
                    self.clear_timer_rebinding();
                    // We are going to Bound state, we must set timer_renewal
                    self.set_timer_renewal();
                    self.set_state(next);
                }
                next @ Renewing => {
                    self.set_state(next);
                }
                next @ Rebinding => {
                    self.set_dhcp_server_id(None);
                    self.clear_timer_rebinding();
                    self.set_timer_expiration();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_expiration is set
            Rebinding => match to {
                next @ RebindingSent => {
                    self.record_request_time();
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
            // timer_expiration is set
            RebindingSent => match to {
                next @ Init => {
                    self.clear_timer_expiration();
                    self.set_state(next);
                }
                next @ Bound => {
                    let ack = expect!(response);
                    self.set_assigned_address(ack.your_ip_address);
                    self.set_dhcp_server_id(Some(expect!(ack.options.dhcp_server_id)));
                    self.set_times(
                        ack.options.renewal_time,
                        ack.options.rebinding_time,
                        expect!(ack.options.address_time),
                    );
                    self.clear_timer_expiration();
                    // We are going to Bound state, we must set timer_renewal
                    self.set_timer_renewal();
                    self.set_state(next);
                }
                next @ Rebinding => {
                    self.set_state(next);
                }
                _ => panic_state!(from, to),
            },
        }
    }

    pub fn dhcp_state(self: &mut Pin<&mut Self>) -> DhcpState {
        *self.as_mut().project().dhcp_state
    }

    pub fn is_broadcast(self: &mut Pin<&mut Self>) -> bool {
        *self.as_mut().project().is_broadcast
    }

    pub fn xid(self: &mut Pin<&mut Self>) -> u32 {
        *self.as_mut().project().transaction_id
    }

    pub fn offered_address(self: &mut Pin<&mut Self>) -> Ipv4Addr {
        self.as_mut().project().offered_address.to_owned()
    }

    pub fn offered_time(self: &mut Pin<&mut Self>) -> u32 {
        *self.as_mut().project().offered_time
    }

    pub fn dhcp_server_id(self: &mut Pin<&mut Self>) -> Option<Ipv4Addr> {
        *self.as_mut().project().dhcp_server_id
    }

    pub fn assigned_address(self: &mut Pin<&mut Self>) -> Ipv4Addr {
        self.as_mut().project().assigned_address.to_owned()
    }

    #[allow(dead_code)]
    fn set_broadcast(self: &mut Pin<&mut Self>, value: bool) {
        *self.as_mut().project().is_broadcast = value;
    }

    fn set_offered_address(self: &mut Pin<&mut Self>, value: Ipv4Addr) {
        *self.as_mut().project().offered_address = value;
    }

    fn set_offered_time(self: &mut Pin<&mut Self>, value: u32) {
        *self.as_mut().project().offered_time = value;
    }

    fn set_dhcp_server_id(self: &mut Pin<&mut Self>, value: Option<Ipv4Addr>) {
        *self.as_mut().project().dhcp_server_id = value;
    }

    fn set_assigned_address(self: &mut Pin<&mut Self>, value: Ipv4Addr) {
        *self.as_mut().project().assigned_address = value;
    }

    fn record_request_time(self: &mut Pin<&mut Self>) {
        *self.as_mut().project().requested_at = Instant::now();
    }

    fn set_times(
        self: &mut Pin<&mut Self>,
        renewal_time: Option<u32>,
        rebinding_time: Option<u32>,
        expiration_time: u32,
    ) {
        let renewal_time =
            renewal_time.unwrap_or(((expiration_time as f64) * RENEWAL_TIME_FACTOR) as u32);
        let rebinding_time =
            rebinding_time.unwrap_or(((expiration_time as f64) * REBINDING_TIME_FACTOR) as u32);

        let seconds_since_request = self.requested_at.elapsed().as_secs();
        *self.as_mut().project().renewal_after = u64::from(renewal_time).saturating_sub(seconds_since_request);
        *self.as_mut().project().rebinding_after = u64::from(rebinding_time).saturating_sub(self.renewal_after);
        *self.as_mut().project().expiration_after = u64::from(expiration_time)
            .saturating_sub(self.renewal_after)
            .saturating_sub(self.rebinding_after);
    }

    fn set_timer_offer(self: &mut Pin<&mut Self>) {
        self.as_mut().project().timer_offer.set(Some(Backoff::new(
            Duration::from_secs(BACKOFF_TIMEOUT_INITIAL),
            Duration::from_secs(BACKOFF_TIMEOUT_MAXIMUM),
        )));
    }

    fn clear_timer_offer(self: &mut Pin<&mut Self>) {
        self.as_mut().project().timer_offer.set(None);
    }

    pub fn poll_timer_offer(self: &mut Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<(u64, bool)>> {
        self.as_mut().project().timer_offer.as_pin_mut().expect("Timer setting logic bug").poll_next(cx)
    }

    fn set_timer_ack(self: &mut Pin<&mut Self>) {
        self.as_mut().project().timer_ack.set(Some(Backoff::new(
            Duration::from_secs(BACKOFF_TIMEOUT_INITIAL),
            Duration::from_secs(BACKOFF_TIMEOUT_MAXIMUM),
        )));
    }

    fn clear_timer_ack(self: &mut Pin<&mut Self>) {
        self.as_mut().project().timer_ack.set(None);
    }

    pub fn poll_timer_ack(self: &mut Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<(u64, bool)>> {
        self.as_mut().project().timer_ack.as_pin_mut().expect("Timer setting logic bug").poll_next(cx)
    }

    fn set_timer_renewal(self: &mut Pin<&mut Self>) {
        let renewal_after = *self.as_mut().project().renewal_after;
        self.as_mut().project().timer_renewal.set(Some(tokio_sleep(
            Duration::from_secs(renewal_after),
        )));
    }

    fn clear_timer_renewal(self: &mut Pin<&mut Self>) {
        self.as_mut().project().timer_renewal.set(None);
    }

    pub fn poll_timer_renewal(self: &mut Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        self.as_mut().project().timer_renewal.as_pin_mut().expect("Timer setting logic bug").poll(cx)
    }

    fn set_timer_rebinding(self: &mut Pin<&mut Self>) {
        let rebinding_after = *self.as_mut().project().rebinding_after;
        self.as_mut().project().timer_rebinding.set(Some(Forthon::new(
            Duration::from_secs(rebinding_after),
            Duration::from_secs(FORTHON_TIMEOUT_MINIMAL),
        )));
    }

    fn clear_timer_rebinding(self: &mut Pin<&mut Self>) {
        self.as_mut().project().timer_rebinding.set(None);
    }

    pub fn poll_timer_rebinding(self: &mut Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<(u64, bool)>> {
        self.as_mut().project().timer_rebinding.as_pin_mut().expect("Timer setting logic bug").poll_next(cx)
    }

    fn set_timer_expiration(self: &mut Pin<&mut Self>) {
        let expiration_after = *self.as_mut().project().expiration_after;
        self.as_mut().project().timer_expiration.set(Some(Forthon::new(
            Duration::from_secs(expiration_after),
            Duration::from_secs(FORTHON_TIMEOUT_MINIMAL),
        )));
    }

    fn clear_timer_expiration(self: &mut Pin<&mut Self>) {
        self.as_mut().project().timer_expiration.set(None);
    }

    pub fn poll_timer_expiration(self: &mut Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<(u64, bool)>> {
        self.as_mut().project().timer_expiration.as_pin_mut().expect("Timer setting logic bug").poll_next(cx)
    }
}
