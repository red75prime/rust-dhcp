//! The DHCP database implementation with address allocating algorithms.

use std::{cmp, net::Ipv4Addr};

use lease::Lease;
use storage::{self, Storage};

/// T1 RFC 2131 suggestion.
const RENEWAL_TIME_FACTOR: f64 = 0.5;
/// T2 RFC 2131 suggestion.
const REBINDING_TIME_FACTOR: f64 = 0.875;
/// 24 hours.
const DEFAULT_LEASE_TIME: u32 = 60 * 60 * 24;
/// 1 week.
const MAX_LEASE_TIME: u32 = 60 * 60 * 24 * 7;

/// Errors generated by `Database` methods.
#[derive(Fail, Debug)]
pub enum Error {
    #[fail(display = "Database error")]
    Storage(storage::Error),
    #[fail(display = "The dynamic pool has been exhausted")]
    DynamicPoolExhausted,

    #[fail(display = "The requested address is not offered")]
    OfferNotFound,
    #[fail(display = "The offer is invalid")]
    OfferInvalid,
    #[fail(display = "The offer is expired")]
    OfferExpired,

    #[fail(display = "Lease not found")]
    LeaseNotFound,
    #[fail(display = "The lease is invalid")]
    LeaseInvalid,
}

impl From<storage::Error> for Error {
    fn from(error: storage::Error) -> Self {
        Error::Storage(error)
    }
}

/// Data required to create a `DHCPOFFER` message.
///
/// Is returned by `Storage::allocate` method.
#[derive(Debug)]
pub struct Offer {
    pub address: Ipv4Addr,
    pub lease_time: u32,
    pub message: String,
}

/// Data required to create a `DHCPACK` message.
///
/// Is returned by `Storage::assign` method.
#[derive(Debug)]
pub struct Ack {
    pub address: Ipv4Addr,
    pub lease_time: u32,
    pub renewal_time: u32,
    pub rebinding_time: u32,
    pub message: String,
}

/// DHCP persistent lease database.
pub struct Database<S>
where
    S: Storage,
{
    /// The inclusive static address range.
    static_address_range: (Ipv4Addr, Ipv4Addr),
    /// The inclusive dynamic address range.
    dynamic_address_range: (Ipv4Addr, Ipv4Addr),
    /// A user defined persistent DHCP database.
    storage: S,
}

impl<S> Database<S>
where
    S: Storage,
{
    /// Creates a new storage with the specified static and dynamic address pools.
    pub fn new(
        static_address_range: (Ipv4Addr, Ipv4Addr),
        dynamic_address_range: (Ipv4Addr, Ipv4Addr),
        storage: S,
    ) -> Self {
        Database {
            static_address_range,
            dynamic_address_range,
            storage,
        }
    }

    /// Allocates an address.
    ///
    /// Address allocation algorithm:
    /// RFC 2132 ยง4.3.1
    /// If an address is available, the new address SHOULD be chosen as follows:
    /// 1. The client's current address as recorded in the client's current
    /// binding, ELSE
    /// 2. The client's previous address as recorded in the client's (now
    /// expired or released) binding, if that address is in the server's
    /// pool of available addresses and not already allocated, ELSE
    /// 3. The address requested in the 'Requested IP Address' option, if that
    /// address is valid and not already allocated, ELSE
    /// 4. A new address allocated from the server's pool of available
    /// addresses; the address is selected based on the subnet from which
    /// the message was received (if 'giaddr' is 0) or on the address of
    /// the relay agent that forwarded the message ('giaddr' when not 0).
    ///
    /// Lease time calculation algorithm:
    /// RFC 2132 ยง4.3.1
    /// The server must also choose an expiration time for the lease, as follows:
    /// 1. IF the client has not requested a specific lease in the
    /// DHCPDISCOVER message and the client already has an assigned network
    /// address, the server returns the lease expiration time previously
    /// assigned to that address (note that the client must explicitly
    /// request a specific lease to extend the expiration time on a
    /// previously assigned address), ELSE
    /// 2. IF the client has not requested a specific lease in the
    /// DHCPDISCOVER message and the client does not have an assigned
    /// network address, the server assigns a locally configured default
    /// lease time, ELSE
    /// 3. IF the client has requested a specific lease in the DHCPDISCOVER
    /// message (regardless of whether the client has an assigned network
    /// address), the server may choose either to return the requested
    /// lease (if the lease is acceptable to local policy) or select
    /// another lease.
    ///
    /// # Errors
    /// `self::Error` on internal storage error.
    /// `self::Error` on dynamic pool exhaustion.
    pub fn allocate(
        &mut self,
        client_id: &[u8],
        lease_time: Option<u32>,
        requested_address: Option<Ipv4Addr>,
    ) -> Result<Offer, Error> {
        // for lease time case 1
        let reuse_lease_time = lease_time.is_none();
        // lease time case 2 or 3
        let lease_time = cmp::min(lease_time.unwrap_or(DEFAULT_LEASE_TIME), MAX_LEASE_TIME);

        // address allocation case 1
        if let Some(address) = self.client_current_address(client_id)? {
            if self.is_address_allocated_by(&address, client_id)?
                && !self.is_address_frozen(&address)?
            {
                // lease time case 1
                let lease_time = self.offer(&address, client_id, lease_time, reuse_lease_time)?;
                let offer = Offer {
                    address,
                    lease_time,
                    message: "Offering the current address".to_owned(),
                };
                trace!(
                    "Offering to the client {:?} the current address {}",
                    client_id,
                    offer.address
                );
                return Ok(offer);
            } else {
                trace!("Client {:?} has no current address", client_id);
            }
        } else {
            trace!("Client {:?} has no current address", client_id);
        }

        // address allocation case 2
        if let Some(address) = self.client_last_address(client_id)? {
            if self.is_address_available(&address)? {
                let lease_time = self.offer(&address, client_id, lease_time, false)?;
                let offer = Offer {
                    address,
                    lease_time,
                    message: "Offering the previous address".to_owned(),
                };
                trace!(
                    "Offering to the client {:?} the previous address {}",
                    client_id,
                    offer.address
                );
                return Ok(offer);
            } else {
                trace!("The previous address {} is not available", address);
            }
        } else {
            trace!("Client {:?} has never had an address", client_id);
        }

        // address allocation case 3
        if let Some(address) = requested_address {
            if self.is_address_available(&address)? {
                let lease_time = self.offer(&address, client_id, lease_time, false)?;
                let offer = Offer {
                    address,
                    lease_time,
                    message: "Offering the requested address".to_owned(),
                };
                trace!(
                    "Offering to the client {:?} the requested address {}",
                    client_id,
                    offer.address
                );
                return Ok(offer);
            } else {
                trace!("The requested address {} is not available", address);
            }
        } else {
            trace!("Client {:?} does not request an address", client_id);
        }

        // address allocation case 4, giaddr stuff not implemented
        let address = self
            .get_dynamic_available()?
            .ok_or(Error::DynamicPoolExhausted)?;
        let lease_time = self.offer(&address, client_id, lease_time, false)?;
        let offer = Offer {
            address,
            lease_time,
            message: "Offering an address from the dynamic pool".to_owned(),
        };
        trace!(
            "Offering to the client {:?} the address {} from the dynamic pool",
            client_id,
            offer.address
        );
        Ok(offer)
    }

    /// Assigns a previously offered address.
    ///
    /// # Errors
    /// `self::Error` on internal storage error.
    /// `self::Error` on address assignment error.
    pub fn assign(
        &mut self,
        client_id: &[u8],
        address: &Ipv4Addr,
        lease_time: Option<u32>,
    ) -> Result<Ack, Error> {
        if let Some(lease) = self.storage.get_lease(&client_id)? {
            if lease.is_offered() {
                if lease.address() != *address {
                    return Err(Error::OfferInvalid);
                }
                if lease.is_offer_expired() {
                    return Err(Error::OfferExpired);
                }
                let lease_time =
                    cmp::min(lease_time.unwrap_or(lease.lease_time()), lease.lease_time());
                self.storage
                    .update_lease(client_id, &mut |lease: &mut Lease| lease.assign(lease_time))?;
                let ack = Ack {
                    address: Ipv4Addr::from(lease.address()),
                    lease_time: lease.lease_time(),
                    renewal_time: ((lease.lease_time() as f64) * RENEWAL_TIME_FACTOR) as u32,
                    rebinding_time: ((lease.lease_time() as f64) * REBINDING_TIME_FACTOR) as u32,
                    message: "Successfully assigned".to_owned(),
                };
                trace!(
                    "Assigning the address {} to client {:?}",
                    ack.address,
                    client_id
                );
                return Ok(ack);
            } else {
                return Err(Error::OfferNotFound);
            }
        }
        Err(Error::OfferNotFound)
    }

    /// Renewes a previously assigned address.
    ///
    /// # Errors
    /// `self::Error` on internal storage error.
    /// `self::Error` on address renewal error.
    pub fn renew(
        &mut self,
        client_id: &[u8],
        address: &Ipv4Addr,
        lease_time: Option<u32>,
    ) -> Result<Ack, Error> {
        let lease_time = cmp::min(lease_time.unwrap_or(DEFAULT_LEASE_TIME), MAX_LEASE_TIME);
        if let Some(lease) = self.storage.get_lease(&client_id)? {
            if lease.address() == *address {
                self.storage
                    .update_lease(client_id, &mut |lease: &mut Lease| lease.renew(lease_time))?;
                let ack = Ack {
                    address: Ipv4Addr::from(lease.address()),
                    lease_time: lease.lease_time(),
                    renewal_time: ((lease.lease_time() as f64) * RENEWAL_TIME_FACTOR) as u32,
                    rebinding_time: ((lease.lease_time() as f64) * REBINDING_TIME_FACTOR) as u32,
                    message: "Your lease has been renewed".to_owned(),
                };
                trace!(
                    "Renewing the address {} for client {:?}",
                    ack.address,
                    client_id
                );
                return Ok(ack);
            } else {
                Err(Error::LeaseInvalid)
            }
        } else {
            Err(Error::LeaseNotFound)
        }
    }

    /// Deallocates a previously offered or assigned address.
    /// Does not return an error if the address has not been allocated.
    ///
    /// # Errors
    /// `self::Error` on internal storage error.
    pub fn deallocate(&mut self, client_id: &[u8], address: &Ipv4Addr) -> Result<(), Error> {
        self.storage.delete_client(address)?;
        self.storage
            .update_lease(client_id, &mut |lease: &mut Lease| lease.release())?;
        Ok(())
    }

    /// Freezes an address due to a `DHCPDECLINE` message.
    ///
    /// # Errors
    /// `self::Error` on internal storage error.
    pub fn freeze(&mut self, address: &Ipv4Addr) -> Result<(), Error> {
        self.storage.add_frozen(address)?;
        Ok(())
    }

    /// Checks the address of a client in the `INIT-REBOOT` state.
    ///
    /// # Errors
    /// `self::Error` on internal storage error.
    /// `self::Error` if the address is not leased to the client.
    pub fn check(&self, client_id: &[u8], address: &Ipv4Addr) -> Result<Ack, Error> {
        if let Some(lease) = self.storage.get_lease(&client_id)? {
            if lease.address() == *address && !lease.is_expired() && !lease.is_released() {
                Ok(Ack {
                    address: Ipv4Addr::from(lease.address()),
                    lease_time: lease.lease_time(),
                    renewal_time: ((lease.lease_time() as f64) * RENEWAL_TIME_FACTOR) as u32,
                    rebinding_time: ((lease.lease_time() as f64) * REBINDING_TIME_FACTOR) as u32,
                    message: "Your lease is active".to_owned(),
                })
            } else {
                Err(Error::LeaseInvalid)
            }
        } else {
            Err(Error::LeaseNotFound)
        }
    }

    fn offer(
        &mut self,
        address: &Ipv4Addr,
        client_id: &[u8],
        lease_time: u32,
        reuse_lease_time: bool,
    ) -> Result<u32, Error> {
        self.storage.add_client(address, client_id)?;

        let mut lease_time = lease_time;
        if reuse_lease_time {
            self.storage.get_lease(client_id)?.map(|lease| {
                if lease.is_active() {
                    lease_time = lease.expires_after();
                }
            });
        }

        self.storage
            .add_lease(client_id, Lease::new(address.to_owned(), lease_time))?;
        Ok(lease_time)
    }

    fn client_current_address(&self, client_id: &[u8]) -> Result<Option<Ipv4Addr>, Error> {
        if let Some(lease) = self.storage.get_lease(client_id)? {
            if lease.is_allocated() {
                return Ok(Some(lease.address()));
            }
        }
        Ok(None)
    }

    fn client_last_address(&self, client_id: &[u8]) -> Result<Option<Ipv4Addr>, Error> {
        if let Some(lease) = self.storage.get_lease(client_id)? {
            return Ok(Some(lease.address()));
        }
        Ok(None)
    }

    fn is_address_available(&self, address: &Ipv4Addr) -> Result<bool, Error> {
        Ok(!self.is_address_allocated(address)?
            && !self.is_address_frozen(address)?
            && (self.is_address_in_static_pool(address)
                || self.is_address_in_dynamic_pool(address)))
    }

    fn is_address_allocated(&self, address: &Ipv4Addr) -> Result<bool, Error> {
        if let Some(client_id) = self.storage.get_client(address)? {
            if let Some(lease) = self.storage.get_lease(&client_id)? {
                return Ok(lease.is_allocated());
            }
        }
        Ok(false)
    }

    fn is_address_allocated_by(&self, address: &Ipv4Addr, cid: &[u8]) -> Result<bool, Error> {
        if let Some(client_id) = self.storage.get_client(address)? {
            if cid.to_vec() == client_id {
                if let Some(lease) = self.storage.get_lease(&client_id)? {
                    return Ok(lease.is_allocated());
                }
            }
        }
        Ok(false)
    }

    fn is_address_frozen(&self, address: &Ipv4Addr) -> Result<bool, Error> {
        Ok(self.storage.check_frozen(address)?)
    }

    fn get_dynamic_available(&self) -> Result<Option<Ipv4Addr>, Error> {
        for address in
            u32::from(self.dynamic_address_range.0)..=u32::from(self.dynamic_address_range.1)
        {
            let address = Ipv4Addr::from(address);
            if self.is_address_available(&address)? {
                return Ok(Some(address));
            }
        }
        Ok(None)
    }

    fn is_address_in_static_pool(&self, address: &Ipv4Addr) -> bool {
        self.static_address_range.0 <= *address && *address <= self.static_address_range.1
    }

    fn is_address_in_dynamic_pool(&self, address: &Ipv4Addr) -> bool {
        self.dynamic_address_range.0 <= *address && *address <= self.dynamic_address_range.1
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use storage_ram::RamStorage;

    #[test]
    fn reuses_client_current_address() {
        let mut storage = Database::new(
            (
                Ipv4Addr::new(192, 168, 0, 2),
                Ipv4Addr::new(192, 168, 0, 101),
            ),
            (
                Ipv4Addr::new(192, 168, 0, 101),
                Ipv4Addr::new(192, 168, 0, 200),
            ),
            RamStorage::new(),
        );
        let client_id = vec![1u8];

        let offer1 = storage
            .allocate(
                client_id.as_ref(),
                Some(1000),
                Some(Ipv4Addr::new(192, 168, 0, 11)),
            )
            .unwrap();
        let ack1 = storage
            .assign(client_id.as_ref(), &offer1.address, Some(offer1.lease_time))
            .unwrap();

        let offer2 = storage
            .allocate(
                client_id.as_ref(),
                Some(1000),
                Some(Ipv4Addr::new(192, 168, 0, 12)),
            )
            .unwrap();
        let ack2 = storage
            .assign(client_id.as_ref(), &offer2.address, Some(offer2.lease_time))
            .unwrap();

        assert_eq!(ack1.address, ack2.address);
    }

    #[test]
    fn reuses_client_previous_address() {
        let mut storage = Database::new(
            (
                Ipv4Addr::new(192, 168, 0, 2),
                Ipv4Addr::new(192, 168, 0, 101),
            ),
            (
                Ipv4Addr::new(192, 168, 0, 101),
                Ipv4Addr::new(192, 168, 0, 200),
            ),
            RamStorage::new(),
        );
        let client_id = vec![1u8];

        let offer1 = storage
            .allocate(client_id.as_ref(), Some(1000), None)
            .unwrap();
        let ack1 = storage
            .assign(client_id.as_ref(), &offer1.address, Some(offer1.lease_time))
            .unwrap();
        storage
            .deallocate(client_id.as_ref(), &ack1.address)
            .unwrap();

        let offer2 = storage
            .allocate(
                client_id.as_ref(),
                Some(1000),
                Some(Ipv4Addr::new(192, 168, 0, 166)),
            )
            .unwrap();
        let ack2 = storage
            .assign(client_id.as_ref(), &offer2.address, Some(offer2.lease_time))
            .unwrap();

        assert_eq!(ack1.address, ack2.address);
    }

    #[test]
    fn uses_deallocated_address_for_new_client() {
        let mut storage = Database::new(
            (
                Ipv4Addr::new(192, 168, 0, 2),
                Ipv4Addr::new(192, 168, 0, 101),
            ),
            (
                Ipv4Addr::new(192, 168, 0, 101),
                Ipv4Addr::new(192, 168, 0, 200),
            ),
            RamStorage::new(),
        );
        let client_id = vec![1u8];
        let another_client_id = vec![2u8];

        let current = Ipv4Addr::new(192, 168, 0, 166);

        let offer1 = storage
            .allocate(client_id.as_ref(), Some(1000), Some(current))
            .unwrap();
        let ack1 = storage
            .assign(client_id.as_ref(), &offer1.address, Some(offer1.lease_time))
            .unwrap();
        storage
            .deallocate(client_id.as_ref(), &ack1.address)
            .unwrap();

        let offer2 = storage
            .allocate(another_client_id.as_ref(), Some(1000), Some(current))
            .unwrap();
        let ack2 = storage
            .assign(
                another_client_id.as_ref(),
                &offer2.address,
                Some(offer2.lease_time),
            )
            .unwrap();

        assert_eq!(ack1.address, ack2.address);
    }

    #[test]
    fn uses_requested_address_if_current_and_previous_are_unavailable() {
        let mut storage = Database::new(
            (
                Ipv4Addr::new(192, 168, 0, 2),
                Ipv4Addr::new(192, 168, 0, 101),
            ),
            (
                Ipv4Addr::new(192, 168, 0, 101),
                Ipv4Addr::new(192, 168, 0, 200),
            ),
            RamStorage::new(),
        );
        let client_id = vec![1u8];
        let another_client_id = vec![2u8];

        let current = Ipv4Addr::new(192, 168, 0, 66);
        let requested = Ipv4Addr::new(192, 168, 0, 77);

        let offer1 = storage
            .allocate(client_id.as_ref(), Some(1000), Some(current))
            .unwrap();
        let ack1 = storage
            .assign(client_id.as_ref(), &offer1.address, Some(offer1.lease_time))
            .unwrap();
        storage
            .deallocate(client_id.as_ref(), &ack1.address)
            .unwrap();

        let offer2 = storage
            .allocate(another_client_id.as_ref(), Some(1000), Some(current))
            .unwrap();
        let _ack2 = storage
            .assign(
                another_client_id.as_ref(),
                &offer2.address,
                Some(offer2.lease_time),
            )
            .unwrap();

        let offer3 = storage
            .allocate(client_id.as_ref(), Some(1000), Some(requested))
            .unwrap();
        let ack3 = storage
            .assign(client_id.as_ref(), &offer3.address, Some(offer3.lease_time))
            .unwrap();

        assert_eq!(ack3.address, requested);
    }

    #[test]
    fn uses_new_address_if_current_and_previous_and_requested_are_unavailable() {
        let mut storage = Database::new(
            (
                Ipv4Addr::new(192, 168, 0, 2),
                Ipv4Addr::new(192, 168, 0, 101),
            ),
            (
                Ipv4Addr::new(192, 168, 0, 101),
                Ipv4Addr::new(192, 168, 0, 200),
            ),
            RamStorage::new(),
        );
        let client_id = vec![1u8];
        let another_client_id = vec![2u8];
        let yet_another_client_id = vec![3u8];

        let current = Ipv4Addr::new(192, 168, 0, 66);
        let requested = Ipv4Addr::new(192, 168, 0, 77);

        let offer1 = storage
            .allocate(client_id.as_ref(), Some(1000), Some(current))
            .unwrap();
        let ack1 = storage
            .assign(client_id.as_ref(), &offer1.address, Some(offer1.lease_time))
            .unwrap();
        storage
            .deallocate(client_id.as_ref(), &ack1.address)
            .unwrap();

        let offer2 = storage
            .allocate(another_client_id.as_ref(), Some(1000), Some(current))
            .unwrap();
        let _ack2 = storage
            .assign(
                another_client_id.as_ref(),
                &offer2.address,
                Some(offer2.lease_time),
            )
            .unwrap();

        let offer3 = storage
            .allocate(yet_another_client_id.as_ref(), Some(1000), Some(requested))
            .unwrap();
        let _ack3 = storage
            .assign(
                yet_another_client_id.as_ref(),
                &offer3.address,
                Some(offer3.lease_time),
            )
            .unwrap();

        let offer4 = storage
            .allocate(client_id.as_ref(), Some(1000), Some(requested))
            .unwrap();
        let ack4 = storage
            .assign(client_id.as_ref(), &offer4.address, Some(offer4.lease_time))
            .unwrap();

        assert_ne!(ack4.address, requested);
    }
}
